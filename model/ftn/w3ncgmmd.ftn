!/
!/ ------------------------------------------------------------------- /
      MODULE W3NCGMMD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           B. G. Reichl            |
!/                  |           J. Meixner              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         01-Aug-2019 |
!/                  +-----------------------------------+
!/
!/    01-Jun-2019 : Origination                        ( version x.xx )
!/
!  1. Purpose :
!
!     Provide modules to read the grid metrics needed for propagation
!     on generalized orthogonal curvilinear grids from netCDF.
!
!  2. Variables and types :
!
!     To be populated.
!
!  3. Subroutines and functions :
!
!      Name          Type  Scope    Description
!     ----------------------------------------------------------------
!      READ_METRICS  Subr. Public   Read metric terms from netCDF.
!      CHECK_RCODE   Subr. Private  Check for errors in netCDF read.
!      NCREAD        Subr. Private  Perform actual reads.
!     ----------------------------------------------------------------
!
!  4. Subroutines and functions used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!      EXTCDE    Subr. W3SERVMD Abort program with exit code.
!     ----------------------------------------------------------------
!
!  5. Called by :
!  6. Error messages :
!  7. Remarks :
!  8. Structure :
!  9. Switches :
! 10. Source code :
!
!/------------------------------------------------------------------- /

      IMPLICIT NONE
!/
      PRIVATE
!/
      PUBLIC READ_METRICS
!/
      LOGICAL, PUBLIC :: FIRST = .TRUE.
!/
      TYPE, PUBLIC :: GRIDINFOTYPE; PRIVATE
         REAL, ALLOCATABLE, DIMENSION(:,:) :: X, Y, DX, DY, ANGLE_DX, AREA
         CHARACTER(LEN=14) :: XVAR_NAME    = 'x',&
                              YVAR_NAME    = 'y',&
                              DXVAR_NAME   = 'dx',&
                              DYVAR_NAME   = 'dy',&
                              ANGVAR_NAME  = 'angle_dx',&
                              AREAVAR_NAME = 'area'
      ENDTYPE GRIDINFOTYPE
!/
      TYPE(GRIDINFOTYPE) :: GRIDINFO
!/
    CONTAINS
!/
      SUBROUTINE READ_METRICS(GRID_METRIC_FILENAME, &
           X, Y, LBI, UBI, LBO, UBO, &
           MASK, GPPC, GQQC, GPQC, GSQR, HPFC, HQFC,&
           APPC, AQQC, APQC, DXDP, DYDP, DXDQ, DYDQ, &
           DPDX, DPDY, DQDX, DQDY, COSA, COSC, SINC, &
           ANGL, SINA, COST, SINT, &
           DADP, DADQ, DADX, DADY, GANGL)
!/
        CHARACTER(50), INTENT(IN) :: GRID_METRIC_FILENAME
        INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
        INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
        REAL, INTENT(IN)   :: X(LBI(1):UBI(1),LBI(2):UBI(2))
        REAL, INTENT(IN)   :: Y(LBI(1):UBI(1),LBI(2):UBI(2))
        LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
        REAL, INTENT(OUT), OPTIONAL :: GPPC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: GQQC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: GPQC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: GSQR(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: HPFC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: HQFC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: APPC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: AQQC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: APQC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DXDP(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DYDP(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DXDQ(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DYDQ(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DPDX(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DPDY(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DQDX(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DQDY(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: COSA(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: COSC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: SINC(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: ANGL(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: SINA(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: COST(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: SINT(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DADQ(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DADP(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DADX(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: DADY(LBO(1):UBO(1),LBO(2):UBO(2))
        REAL, INTENT(OUT), OPTIONAL :: GANGL(LBO(1):UBO(1),LBO(2):UBO(2))
!/
        REAL :: GPPCL, GQQCL, GPQCL
        REAL :: GSQRL, HPFCL, HQFCL
        REAL :: APPCL, AQQCL, APQCL
        REAL :: DXDPL, DYDPL, DXDQL, DYDQL
        REAL :: DPDXL, DPDYL, DQDXL, DQDYL
        REAL :: COSAL, SINAL, COSTP, SINTP, COSCL, SINCL, ANGLL
        REAL :: DADPL, DADQL, DADXL, DADYL, GANGLL
!/
        INTEGER :: I2, I1, P, Q, P_, Q_
!/
        IF (FIRST) THEN

           WRITE(*,*)'  Reading Grid Metric Terms from file ',&
                TRIM(GRID_METRIC_FILENAME)
           WRITE(*,*)'  --------------------------------------------------'

           call READ_NC(GRID_METRIC_FILENAME,GRIDINFO%XVAR_NAME )
           call READ_NC(GRID_METRIC_FILENAME,GRIDINFO%YVAR_NAME )
           call READ_NC(GRID_METRIC_FILENAME,GRIDINFO%DXVAR_NAME )
           call READ_NC(GRID_METRIC_FILENAME,GRIDINFO%DYVAR_NAME )
           call READ_NC(GRID_METRIC_FILENAME,GRIDINFO%ANGVAR_NAME )
           call READ_NC(GRID_METRIC_FILENAME,GRIDINFO%AREAVAR_NAME )

           FIRST = .FALSE.

        ENDIF
!/
        DO I2 = LBO(2), UBO(2)
           DO I1 = LBO(1), UBO(1)
              P=I2;Q=I1
              IF (.TRUE.) THEN !(.not. MASK(Q,P)) then
                 P_ = (P-1) *2 + 1
                 Q_ = (Q-1) *2 + 1
                 !
                 !             1       2
                 !   5     x---x---x---x---x
                 ! 4       |   |   |   |   |
                 !   4     x---o---x---o---x 2 Q_
                 ! 3       |   |   |   |   |
                 !   3  Q_ x---x---x---x---x
                 ! 2       |   |   |   |   |
                 !   2     x---o---x---o---x 1 Q_
                 ! 1       |   |   |   |   |
                 !   1     x---x---x---x---x
                 !                 P_
                 !         1   2   3   4   5
                 !            1   2   3   4
                 !  DX/DP is DX(p,q+1) + DX(p+1,q+1)
                 !  DY/DP is (DY(P+2,Q) + DY(P+2,Q+1)) - (DY(P,Q) + DY(P,Q+1))
                 !  DX/DQ is (DX(P,Q+2) + DX(P+1,Q+2)) - (DX(P,Q) + DX(P+1,Q))
                 !  DY/DQ is DY(P+1,Q) + DY(P+1,Q+1)
                 !  DA/DQ is GANGL(P_+1,Q_+2) - GANGL(P_+1,Q_)
                 !  DA/DP is GANGL(P_+2,Q_+1) - GANGL(P_,Q_+1)
                 DXDPL = GRIDINFO%DX(P_,Q_+1) + GRIDINFO%DX(P_+1,Q_+1)
                 DYDPL = ( GRIDINFO%DY(P_+2,Q_) + GRIDINFO%DY(P_+2,Q_+1) ) - &
                      ( GRIDINFO%DY(P_,Q_) + GRIDINFO%DY(P_,Q_+1) )
                 DXDQL = ( GRIDINFO%DX(P_,Q_+2) + GRIDINFO%DX(P_+1,Q_+2) ) - &
                      ( GRIDINFO%DX(P_,Q_) + GRIDINFO%DX(P_+1,Q_) )
                 DYDQL = GRIDINFO%DY(P_+1,Q_) + GRIDINFO%DY(P_+1,Q_+1)
                 DADQL = GRIDINFO%ANGLE_DX(P_+1,Q_+2) - GRIDINFO%ANGLE_DX(P_+1,Q_)
                 DADPL = GRIDINFO%ANGLE_DX(P_+2,Q_+1) - GRIDINFO%ANGLE_DX(P_,Q_+1)
                 GSQRL = DXDPL*DYDQL - DXDQL*DYDPL
                 IF ( GSQRL .LT. 0.0 ) THEN
                    WRITE(*,*) ' ERROR IN W3NCGMMD, ',&
                         ' GSQRL: ',GSQRL,&
                         ' DXDPL: ',DXDPL,&
                         ' DX(P,Q+1): ',GRIDINFO%DX(P_,Q_+1),&
                         ' DX(P+1,Q+1): ',GRIDINFO%DX(P_+1,Q_+1),&
                         ' DYDQL: ',DYDQL,&
                         ' DY(P+1,Q): ',GRIDINFO%DY(P_+1,Q_),&
                         ' DY(P+1,Q+1): ',GRIDINFO%DY(P_+1,Q_+1),&
                         ' DXDQL: ',DXDQL,&
                         ' DYDPL: ',DYDPL,&
                         ' I2,I1: ',I2,I1
                 ENDIF
                 GPPCL = DXDPL*DXDPL + DYDPL*DYDPL
                 GQQCL = DXDQL*DXDQL + DYDQL*DYDQL
                 GPQCL = DXDPL*DXDQL + DYDPL*DYDQL
                 GSQRL = MAX(GSQRL,1.e-15)
                 GPPCL = MAX(GPPCL,1.e-15)
                 GQQCL = MAX(GQQCL,1.e-15)
                 DPDXL = DYDQL/GSQRL
                 DPDYL =-DXDQL/GSQRL
                 DQDXL =-DYDPL/GSQRL
                 DQDYL = DXDPL/GSQRL
                 APPCL = DPDXL*DPDXL + DPDYL*DPDYL
                 AQQCL = DQDXL*DQDXL + DQDYL*DQDYL
                 APQCL = DPDXL*DQDXL + DPDYL*DQDYL
                 HPFCL = SQRT(GPPCL)
                 HQFCL = SQRT(GQQCL)
                 COSAL = GPQCL/(HPFCL*HQFCL)
                 SINAL = GSQRL**2/(GPPCL*GQQCL)
                 COSTP = DXDPL/HPFCL
                 SINTP = DYDPL/HQFCL
                 COSCL = SINAL*COSTP + COSAL*SINTP
                 SINCL = SINAL*SINTP - COSAL*COSTP
                 ANGLL = ATAN2(SINCL,COSCL)*180./3.1415
                 DADXL = DADPL*DPDXL+DADQL*DQDXL
                 DADYL = DADPL*DPDYL+DADQL*DQDYL
                 GANGLL = GRIDINFO%ANGLE_DX(P_+1,Q_+1)
                 IF (PRESENT(GPPC)) GPPC(I1,I2) = GPPCL
                 IF (PRESENT(GQQC)) GQQC(I1,I2) = GQQCL
                 IF (PRESENT(GPQC)) GPQC(I1,I2) = GPQCL
                 IF (PRESENT(APPC)) APPC(I1,I2) = APPCL
                 IF (PRESENT(AQQC)) AQQC(I1,I2) = AQQCL
                 IF (PRESENT(APQC)) APQC(I1,I2) = APQCL
                 IF (PRESENT(GSQR)) GSQR(I1,I2) = GSQRL
                 IF (PRESENT(HPFC)) HPFC(I1,I2) = HPFCL
                 IF (PRESENT(HQFC)) HQFC(I1,I2) = HQFCL
                 IF (PRESENT(DXDP)) DXDP(I1,I2) = DXDPL
                 IF (PRESENT(DYDP)) DYDP(I1,I2) = DYDPL
                 IF (PRESENT(DXDQ)) DXDQ(I1,I2) = DXDQL
                 IF (PRESENT(DYDQ)) DYDQ(I1,I2) = DYDQL
                 IF (PRESENT(DPDX)) DPDX(I1,I2) = DPDXL
                 IF (PRESENT(DPDY)) DPDY(I1,I2) = DPDYL
                 IF (PRESENT(DQDX)) DQDX(I1,I2) = DQDXL
                 IF (PRESENT(DQDY)) DQDY(I1,I2) = DQDYL
                 IF (PRESENT(COSA)) COSA(I1,I2) = COSAL
                 IF (PRESENT(COSC)) COSC(I1,I2) = COSCL
                 IF (PRESENT(SINC)) SINC(I1,I2) = SINCL
                 IF (PRESENT(ANGL)) ANGL(I1,I2) = ANGLL
                 IF (PRESENT(DADP)) DADP(I1,I2) = DADPL
                 IF (PRESENT(DADQ)) DADQ(I1,I2) = DADQL
                 IF (PRESENT(DADX)) DADX(I1,I2) = DADXL
                 IF (PRESENT(DADY)) DADY(I1,I2) = DADYL
                 IF (PRESENT(GANGL)) GANGL(I1,I2) = GANGLL
              else
                 IF (PRESENT(GPPC)) GPPC(I1,I2) = 0.
                 IF (PRESENT(GQQC)) GQQC(I1,I2) = 0.
                 IF (PRESENT(GPQC)) GPQC(I1,I2) = 0.
                 IF (PRESENT(APPC)) APPC(I1,I2) = 0.
                 IF (PRESENT(AQQC)) AQQC(I1,I2) = 0.
                 IF (PRESENT(APQC)) APQC(I1,I2) = 0.
                 IF (PRESENT(GSQR)) GSQR(I1,I2) = 0.
                 IF (PRESENT(HPFC)) HPFC(I1,I2) = 0.
                 IF (PRESENT(HQFC)) HQFC(I1,I2) = 0.
                 IF (PRESENT(DXDP)) DXDP(I1,I2) = 0.
                 IF (PRESENT(DYDP)) DYDP(I1,I2) = 0.
                 IF (PRESENT(DXDQ)) DXDQ(I1,I2) = 0.
                 IF (PRESENT(DYDQ)) DYDQ(I1,I2) = 0.
                 IF (PRESENT(DPDX)) DPDX(I1,I2) = 0.
                 IF (PRESENT(DPDY)) DPDY(I1,I2) = 0.
                 IF (PRESENT(DQDX)) DQDX(I1,I2) = 0.
                 IF (PRESENT(DQDY)) DQDY(I1,I2) = 0.
                 IF (PRESENT(COSA)) COSA(I1,I2) = 0.
                 IF (PRESENT(COSC)) COSC(I1,I2) = 0.
                 IF (PRESENT(SINC)) SINC(I1,I2) = 0.
                 IF (PRESENT(ANGL)) ANGL(I1,I2) = 0.
                 IF (PRESENT(DADP)) DADP(I1,I2) = 0.
                 IF (PRESENT(DADQ)) DADQ(I1,I2) = 0.
                 IF (PRESENT(DADX)) DADX(I1,I2) = 0.
                 IF (PRESENT(DADY)) DADY(I1,I2) = 0.
                 IF (PRESENT(GANGL)) GANGL(I1,I2) = 0.
              ENDIF
           ENDDO
        ENDDO

        RETURN
      ENDSUBROUTINE READ_METRICS

      SUBROUTINE CHECKRCODE(RC, ERRORFLAG)

        INTEGER, INTENT(IN) :: RC, ERRORFLAG

        IF (RC.NE.0) THEN
           IF (ERRORFLAG==1) &
                WRITE(*,*) 'Error in reading Grid Metrics from file, file not found.'
           IF (ERRORFLAG==2) &
                write(*,*) 'Error in reading Grid Metrics from file, probing NetCDF file.'
           IF (ERRORFLAG==3) &
                WRITE(*,*) 'Error in reading Grid Metrics from file, probing NetCDF variable.'
           IF (ERRORFLAG==4) &
                WRITE(*,*) 'Error in reading Grid Metrics from file, reading NetCDF dimension.'
           IF (ERRORFLAG==5) &
                WRITE(*,*) 'Error in reading Grid Metrics from file, reading NetCDF variable.'
           STOP
        ENDIF
      ENDSUBROUTINE CheckRcode
!/
      SUBROUTINE READ_NC(GRID_METRIC_FILENAME, VAR)
!/
        USE NETCDF
!/
        CHARACTER(LEN=50), INTENT(IN) &
             :: GRID_METRIC_FILENAME !< The filename for the netCDF file.
        CHARACTER(LEN=14), INTENT(IN) &
             :: VAR !< The variable to be read from the netCDF file.
!/
        INTEGER :: NCID, VAR_ID
        INTEGER :: NDIMS, LEN_DIM_1, LEN_DIM_2
        INTEGER, DIMENSION(2) :: DIMS, DIM_ID, START, FINISH
        CHARACTER(LEN=14) :: DIM_NAME(4)
        INTEGER :: RCODE

        WRITE(*,*) '      READING GRID METRIC: ', TRIM(VAR)

        RCODE = NF90_OPEN(TRIM(GRID_METRIC_FILENAME), NF90_NOWRITE, NCID)
        CALL CHECKRCODE(RCODE,1)
        RCODE = NF90_INQ_VARID(NCID, VAR, VAR_ID)
        CALL CHECKRCODE(RCODE,2)
        RCODE=NF90_INQUIRE_VARIABLE(NCID, VAR_ID, NDIMS=NDIMS, DIMIDS=DIM_ID)
        CALL CHECKRCODE(RCODE,3)
        RCODE=NF90_INQUIRE_DIMENSION(NCID, DIM_ID(1), DIM_NAME(1), LEN=LEN_DIM_1)
        CALL CHECKRCODE(RCODE,4)
        RCODE=NF90_INQUIRE_DIMENSION(NCID, DIM_ID(2), DIM_NAME(2), LEN=LEN_DIM_2)
        CALL CHECKRCODE(RCODE,4)
        START(1)=1;START(2)=1;FINISH(1)=LEN_DIM_1;FINISH(2)=LEN_DIM_2

        IF (TRIM(VAR) == TRIM(GRIDINFO%XVAR_NAME)) THEN
           ALLOCATE(GRIDINFO%X(LEN_DIM_1,LEN_DIM_2))
           RCODE=NF90_GET_VAR(NCID, VAR_ID, GRIDINFO%X, START, FINISH)
           CALL CHECKRCODE(RCODE,5)
        ELSEIF (TRIM(VAR) == TRIM(GRIDINFO%YVAR_NAME)) THEN
           ALLOCATE(GRIDINFO%Y(LEN_DIM_1,LEN_DIM_2))
           RCODE=NF90_GET_VAR(NCID, VAR_ID, GRIDINFO%Y, START, FINISH)
           CALL CHECKRCODE(RCODE,5)
        ELSEIF (TRIM(VAR) == TRIM(GRIDINFO%DXVAR_NAME)) THEN
           ALLOCATE(GRIDINFO%DX(LEN_DIM_1,LEN_DIM_2))
           RCODE=NF90_GET_VAR(NCID, VAR_ID, GRIDINFO%DX, START, FINISH)
           CALL CHECKRCODE(RCODE,5)
        ELSEIF (TRIM(VAR) == TRIM(GRIDINFO%DYVAR_NAME)) THEN
           ALLOCATE(GRIDINFO%DY(LEN_DIM_1,LEN_DIM_2))
           RCODE=NF90_GET_VAR(NCID, VAR_ID, GRIDINFO%DY, START, FINISH)
           CALL CHECKRCODE(RCODE,5)
        ELSEIF (TRIM(VAR) == TRIM(GRIDINFO%ANGVAR_NAME)) THEN
           ALLOCATE(GRIDINFO%ANGLE_DX(LEN_DIM_1,LEN_DIM_2))
           RCODE=NF90_GET_VAR(NCID, VAR_ID, GRIDINFO%ANGLE_DX, START, FINISH)
           CALL CHECKRCODE(RCODE,5)
        ELSEIF (TRIM(VAR) == TRIM(GRIDINFO%AREAVAR_NAME)) THEN
           ALLOCATE(GRIDINFO%AREA(LEN_DIM_1,LEN_DIM_2))
           RCODE=NF90_GET_VAR(NCID, VAR_ID, GRIDINFO%AREA, START, FINISH)
           CALL CHECKRCODE(RCODE,5)
        ENDIF

        RCODE=NF90_CLOSE(NCID)
      ENDSUBROUTINE READ_NC

    ENDMODULE W3NCGMMD
